<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disjoint Set (Union-Find) Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f8f9fa;
      overflow: hidden;
    }

    /* layout grid: left controls/explain, center canvas, right info */
    #layout { display: grid; grid-template-columns: minmax(260px,360px) 1fr minmax(300px,420px); gap:12px; height:100vh; }
    #left { padding:12px; overflow:auto; }
    #center { position:relative; }
    #right { padding:12px; overflow:auto; }

    #controls {
      background: white;
      padding: 12px 14px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      font-size: 14px;
      max-width: 100%;
    }

    #controls label { display: inline-block; width: 60px; }

    input[type="number"], button, select {
      margin: 4px 6px 4px 0;
      padding: 6px 8px;
      font-size: 13px;
    }

    button {
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.15s;
    }

    button:hover { background-color: #0056b3; }

    /* center canvas fills the center grid cell */
    #center svg {
      position: absolute;
      inset: 0; /* top:0; right:0; bottom:0; left:0 */
      width: 100%;
      height: 100%;
      background: transparent;
    }

    /* small screens: stack columns vertically */
    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; }
      #center { min-height: 56vh; }
      #left, #right { padding:10px; }
    }

    circle {
      stroke: #222;
      stroke-width: 2px;
      cursor: pointer;
      transition: fill 0.2s;
    }

    line {
      stroke: #555;
      stroke-width: 2px;
    }

    text {
      fill: white;
      font-weight: bold;
      text-anchor: middle;
      dominant-baseline: middle;
      user-select: none;
    }

    /* small subtitle text for node metadata */
    .meta {
      font-size: 11px;
      fill: #fff;
      opacity: 0.95;
      font-weight: normal;
    }

    /* info panel (right column) */
    #info {
      background: white;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      font-family: monospace;
      font-size: 13px;
      max-height: calc(100vh - 24px);
      overflow:auto;
    }

    #state { white-space: pre; background:#f4f6f8; padding:8px; border-radius:6px; }
    #log { margin-top:8px; max-height:220px; overflow:auto; background:#fff; border-radius:6px; padding:8px; border:1px solid #eee }
    .log-entry { margin-bottom:6px; font-size:13px }
  .log-badge { display:inline-block; min-width:36px; background:#007bff; color:#fff; padding:2px 6px; border-radius:4px; font-weight:600; margin-right:8px; text-align:center }
  .log-msg { color:#222 }
  </style>
</head>
<body>
  <div id="layout">
    <div id="left">
      <div id="controls">
        <div style="margin-bottom:6px">
          <label>Nodes:</label>
          <input id="nodeCount" type="number" value="6" min="2" max="20">
          <button onclick="initialize()">Initialize</button>
        </div>

        <div style="margin-bottom:6px">
          <label>Union:</label>
          <input id="a" type="number" placeholder="A" style="width:60px">
          <input id="b" type="number" placeholder="B" style="width:60px">
          <button onclick="performUnion()">Union(A,B)</button>
          <button onclick="checkConnected()" style="margin-left:6px">Connected?</button>
        </div>

        <div style="margin-bottom:6px">
          <label>Find:</label>
          <input id="f" type="number" placeholder="X" style="width:70px">
          <button onclick="performFind()">Find(X)</button>
        </div>

        <div style="margin-bottom:6px">
          <label>Strategy:</label>
          <select id="strategy">
            <option value="size">Union by size</option>
            <option value="rank">Union by rank</option>
          </select>
          <button onclick="clearLog()" style="float:right">Clear Log</button>
        </div>
      </div>

      <div id="explain" style="max-width:100%; background:white; padding:12px; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.06); margin-top:12px; font-size:14px;">
        <h2 style="margin:4px 0 8px 0; font-size:16px;">Disjoint Set (Union–Find)</h2>
        <p style="margin:0 0 8px 0;">A disjoint set (or union–find) is a data structure that tracks a partition of elements into non-overlapping sets. It supports two primary operations efficiently: <strong>find(x)</strong> — returns the representative (root) of x's set, and <strong>union(a, b)</strong> — merges the sets containing a and b. Optimizations like <em>union by size/rank</em> and <em>path compression</em> make these operations nearly constant time.</p>

        <div style="font-size:13px; color:#333;">
          <strong>Example walkthrough (nodes 0..5)</strong>
          <ol style="padding-left:18px; margin:6px 0 0 0;">
            <li>Start: each node in its own set: {0},{1},{2},{3},{4},{5}.</li>
            <li>Union(0,1) → merge sets: {0,1}, {2}, {3}, {4}, {5}.</li>
            <li>Union(2,3) → {0,1}, {2,3}, {4}, {5}.</li>
            <li>Union(1,2) → merges the two groups into {0,1,2,3}. A subsequent Find(3) returns the group's root (e.g. 0) and path compression attaches members directly to the root for faster future finds.</li>
          </ol>
        </div>
      </div>
    </div>

    <div id="center">
      <svg id="canvas"></svg>
    </div>

    <div id="right">
      <div id="info">
        <div><strong>State</strong></div>
        <pre id="state">parent: []\nsize: []\nrank: []</pre>
        <div style="margin-top:8px"><strong>Action Log</strong></div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <script>
  // The canvas size is taken from the SVG element (so it sits correctly between left/right panels)
  const svgEl = document.getElementById ? document.getElementById('canvas') : null;
  let width = svgEl ? svgEl.clientWidth : window.innerWidth;
  let height = svgEl ? svgEl.clientHeight : window.innerHeight;

    // node radius is responsive to the canvas size (not the full window)
    function computeNodeRadius() {
      return Math.max(18, Math.min(44, Math.floor(Math.min(width, height) / 25)));
    }
    let NODE_RADIUS = computeNodeRadius();
    // drag handler (attached to node groups)
    const dragHandler = d3.drag()
      .on('start', (event, d) => {
        // bring dragged node to front
        d3.select(event.sourceEvent.target.parentNode).raise();
      })
      .on('drag', (event, d) => {
        d.x = Math.max(NODE_RADIUS + 8, Math.min(width - NODE_RADIUS - 8, event.x));
        d.y = Math.max(NODE_RADIUS + 8, Math.min(height - NODE_RADIUS - 8, event.y));
        updateGraph();
      })
      .on('end', (event, d) => {
        // after manual move, keep nodes separated and enforce min edge lengths
        resolveOverlaps(nodes, NODE_RADIUS * 2 + 6);
        updateGraph();
      });

    // minimum link length helper: ensure connected nodes have at least minLen between centers
    function enforceMinLinkLengths(nodesArr, minLen) {
      if (!links || !links.length) return;
      links.forEach(l => {
        const a = l.source, b = l.target;
        let dx = b.x - a.x, dy = b.y - a.y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
        if (dist < minLen) {
          const ux = dx / dist, uy = dy / dist;
          const shift = (minLen - dist) / 2;
          // move both nodes slightly away from each other
          a.x = Math.max(NODE_RADIUS + 8, Math.min(width - NODE_RADIUS - 8, a.x - ux * shift));
          a.y = Math.max(NODE_RADIUS + 8, Math.min(height - NODE_RADIUS - 8, a.y - uy * shift));
          b.x = Math.max(NODE_RADIUS + 8, Math.min(width - NODE_RADIUS - 8, b.x + ux * shift));
          b.y = Math.max(NODE_RADIUS + 8, Math.min(height - NODE_RADIUS - 8, b.y + uy * shift));
        }
      });
    }
    const svg = d3.select("#canvas");
  let ds, nodes = [], links = [], link, node, text;
  let nextId = 0;
  let logCounter = 1;

    class DisjointSet {
      constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.size = Array(n).fill(1);
        this.rank = Array(n).fill(0);
      }

        find(x) {
          if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
          }
          return this.parent[x];
        }

        // union supports two strategies: 'size' or 'rank'
        union(x, y, strategy = 'size') {
          let px = this.find(x), py = this.find(y);
          if (px === py) return { merged: false, root: px };

          if (strategy === 'rank') {
            // union by rank
            if (this.rank[px] < this.rank[py]) [px, py] = [py, px];
            this.parent[py] = px;
            if (this.rank[px] === this.rank[py]) this.rank[px]++;
            // update size array for visualization convenience
            this.size[px] += this.size[py];
          } else {
            // default: union by size
            if (this.size[px] < this.size[py]) [px, py] = [py, px];
            this.parent[py] = px;
            this.size[px] += this.size[py];
          }

          return { merged: true, root: px };
        }
    }

    function initialize() {
      const n = parseInt(document.getElementById("nodeCount").value);
      ds = new DisjointSet(n);
      nodes = [];
      links = [];
      nextId = n;

      // radial layout radius scales with viewport but keeps room for node radius
      NODE_RADIUS = computeNodeRadius();
      const radius = Math.max(120, Math.min(Math.min(width, height) / 2.6, 420)) - NODE_RADIUS * 1.5;

      for (let i = 0; i < n; i++) {
        const angle = (2 * Math.PI / n) * i;
        nodes.push({
          id: i,
          x: width / 2 + radius * Math.cos(angle),
          y: height / 2 + radius * Math.sin(angle),
          parent: i
        });
      }

      // gently separate nodes to avoid overlap on init
      resolveOverlaps(nodes, NODE_RADIUS * 2 + 6);

      // initial render and state
      updateGraph();
      log(`Initialized ${n} nodes`);
      updateStateDisplay();
    }

    // Render/update links and nodes
    function updateGraph() {
      // update links
      links = nodes.filter(n => n.parent !== n.id)
        .map(n => ({ source: nodes[n.id], target: nodes[n.parent] }));

        link = svg.selectAll("line").data(links, d => d.source.id + "-" + d.target.id);

        // enforce minimum edge length before drawing to avoid overlaps
        enforceMinLinkLengths(nodes, NODE_RADIUS * 2 + 6);

        link.enter().append("line")
          .attr("stroke", "#555")
          .merge(link)
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      link.exit().remove();

      // update nodes
      // Use group per node with main label and metadata line
      const g = svg.selectAll("g.node").data(nodes, d => d.id);

      const gEnter = g.enter().append("g").classed('node', true)
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .call(dragHandler);

      gEnter.append("circle")
        .attr("r", NODE_RADIUS)
        .attr("fill", d => (d.id === d.parent ? "#ff9800" : "#4682b4"))
        .attr("stroke", "#222");

      // main id
      gEnter.append("text").classed('main', true)
        .attr("y", -4)
        .text(d => d.id)
        .attr("fill", "white");

      // metadata: parent / size / rank
      gEnter.append("text").classed('meta', true)
        .attr("y", 14)
        .text(d => metaText(d));

  // merge & animate updates
  const gAll = g.merge(gEnter).call(dragHandler);

      gAll.select("circle")
        .transition()
        .duration(500)
        .attr("r", NODE_RADIUS)
        .attr("fill", d => (d.id === d.parent ? "#ff9800" : "#4682b4"));

      gAll.transition()
        .duration(500)
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .select("text.meta")
        .tween("text", function(d) {
          const that = d3.select(this);
          const i = d3.interpolateString(that.text(), metaText(d));
          return t => that.text(i(t));
        });

      g.exit().remove();
    }

    function metaText(d) {
      // show parent, size and rank (if available)
      const s = ds && ds.size ? ds.size[d.id] : '-';
      const r = ds && ds.rank ? ds.rank[d.id] : '-';
      return `p:${d.parent} s:${s} r:${r}`;
    }

    function performUnion() {
      const a = parseInt(document.getElementById("a").value);
      const b = parseInt(document.getElementById("b").value);
      if (isNaN(a) || isNaN(b) || a === b || a >= nodes.length || b >= nodes.length) {
        log('Invalid union inputs or indexes out of range');
        return;
      }

      const strategy = document.getElementById('strategy').value;
      const result = ds.union(a, b, strategy);
      nodes.forEach(n => n.parent = ds.parent[n.id]);

      if (result.merged) {
        log(`Union(${a}, ${b}) by ${strategy} — merged, new root: ${result.root}`);
        animateUnion(a, b, result.root);
      } else {
        log(`Union(${a}, ${b}) by ${strategy} — already in same set (root: ${result.root})`);
      }

      updateStateDisplay();
      setTimeout(updateGraph, 500);
    }

    // Check connectivity between two nodes (uses inputs A and B)
    function checkConnected() {
      const a = parseInt(document.getElementById("a").value);
      const b = parseInt(document.getElementById("b").value);
      if (isNaN(a) || isNaN(b) || a === b || a >= nodes.length || b >= nodes.length) {
        log('Invalid inputs for connectivity check or indexes out of range');
        return;
      }

      const ra = ds.find(a);
      const rb = ds.find(b);
      if (ra === rb) {
        log(`Connected: ${a} and ${b} are in the same set (root: ${ra})`);
        // highlight entire set briefly
        svg.selectAll("circle")
          .transition().duration(200)
          .attr("fill", d => (ds.find(d.id) === ra ? '#28a745' : (d.id === d.parent ? '#ff9800' : '#4682b4')))
          .transition().delay(800).duration(300)
          .attr("fill", d => (d.id === d.parent ? '#ff9800' : '#4682b4'));
      } else {
        log(`Not connected: ${a} (root ${ra}) and ${b} (root ${rb})`);
        // highlight the two nodes in red briefly
        svg.selectAll("circle").filter(d => d.id === a || d.id === b)
          .transition().duration(150).attr("fill", '#e55353')
          .transition().delay(700).duration(300).attr("fill", d => (d.id === d.parent ? '#ff9800' : '#4682b4'));
      }
    }

    function performFind() {
      const f = parseInt(document.getElementById("f").value);
      if (isNaN(f) || f >= nodes.length) return;
      const path = [];
      let x = f;
      while (ds.parent[x] !== x) {
        path.push(x);
        x = ds.parent[x];
      }
      path.push(x);

      log(`Find(${f}) -> root ${x}. Path: [${path.join(' -> ')}]`);

      // Highlight path
      path.forEach((id, i) => {
        svg.selectAll("circle").filter(d => d.id === id)
          .transition().delay(i * 150)
          .duration(250)
          .attr("fill", "#28a745");
      });

      // Determine if any node actually needs its parent updated (i.e., not already direct child of root)
      const intermediates = path.slice(0, -1);
      const needCompression = intermediates.some(id => ds.parent[id] !== x);

      // Compress paths visually and update (only if needed)
      setTimeout(() => {
        if (needCompression) {
          intermediates.forEach(id => {
            // move visually toward root
            nodes[id].parent = x;
            nodes[id].x += (nodes[x].x - nodes[id].x) * 0.3;
            nodes[id].y += (nodes[x].y - nodes[id].y) * 0.3;
          });
          // actually compress in the DS
          ds.find(f);
          nodes.forEach(n => n.parent = ds.parent[n.id]);
          // ensure min link lengths after compression
          enforceMinLinkLengths(nodes, NODE_RADIUS * 2 + 6);
          updateStateDisplay();
          updateGraph();
          log(`Path compression for ${f} completed (now root: ${x})`);
        } else {
          // nothing to compress — reset visuals
          updateGraph();
          log(`Find(${f}): already directly attached to root ${x}; no compression needed`);
        }
      }, path.length * 200);
    }

    // Simple overlap resolver: pushes overlapping nodes apart
    function resolveOverlaps(nodes, minDist) {
      const iterations = 6;
      for (let k = 0; k < iterations; k++) {
        let moved = false;
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i], b = nodes[j];
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
            const overlap = minDist - dist;
            if (overlap > 0) {
              moved = true;
              const ux = dx / dist, uy = dy / dist;
              const shift = overlap * 0.5;
              // push both nodes away from each other
              b.x += ux * shift;
              b.y += uy * shift;
              a.x -= ux * shift;
              a.y -= uy * shift;
              // keep inside viewport margins
              a.x = Math.max(NODE_RADIUS + 8, Math.min(width - NODE_RADIUS - 8, a.x));
              a.y = Math.max(NODE_RADIUS + 8, Math.min(height - NODE_RADIUS - 8, a.y));
              b.x = Math.max(NODE_RADIUS + 8, Math.min(width - NODE_RADIUS - 8, b.x));
              b.y = Math.max(NODE_RADIUS + 8, Math.min(height - NODE_RADIUS - 8, b.y));
            }
          }
        }
        if (!moved) break;
      }
    }

    function animateUnion(a, b, root) {
      // color the merged group briefly, then update graph
      const rootId = root;
      svg.selectAll("circle").filter(d => d.id === a || d.id === b || d.id === rootId)
        .transition().duration(400)
        .attr("fill", "#17a2b8")
        .transition().duration(400)
        .attr("fill", d => (d.id === d.parent ? "#ff9800" : "#4682b4"));
    }

    function log(msg) {
      const el = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      const badge = document.createElement('span');
      badge.className = 'log-badge';
      badge.textContent = `#${logCounter++}`;
      const m = document.createElement('span');
      m.className = 'log-msg';
      m.textContent = msg;
      entry.appendChild(badge);
      entry.appendChild(m);
      el.prepend(entry);
      // limit log length to keep UI small
      while (el.childNodes.length > 200) el.removeChild(el.lastChild);
    }

    function clearLog() { document.getElementById('log').innerHTML = ''; }

    function updateStateDisplay() {
      if (!ds) return;
      const p = ds.parent.join(', ');
      const s = ds.size.join(', ');
      const r = ds.rank.join(', ');
      document.getElementById('state').textContent = `parent: [${p}]\nsize:   [${s}]\nrank:   [${r}]`;
    }

    // Recompute layout on resize to keep things balanced and responsive
    window.addEventListener('resize', () => {
      // read the current svg client dimensions (SVG is centered between panels)
      width = svg.node() ? svg.node().clientWidth : window.innerWidth;
      height = svg.node() ? svg.node().clientHeight : window.innerHeight;
      NODE_RADIUS = computeNodeRadius();
      // recompute circular layout while preserving set structure
      const n = nodes.length;
      const radius = Math.max(120, Math.min(Math.min(width, height) / 2.6, 420)) - NODE_RADIUS * 1.5;
      for (let i = 0; i < n; i++) {
        const angle = (2 * Math.PI / n) * i;
        nodes[i].x = width / 2 + radius * Math.cos(angle);
        nodes[i].y = height / 2 + radius * Math.sin(angle);
      }
      // resolve overlaps after layout
      resolveOverlaps(nodes, NODE_RADIUS * 2 + 6);
      updateGraph();
    });

    // initialize canvas size from SVG before creating nodes
    width = svg.node() ? svg.node().clientWidth : window.innerWidth;
    height = svg.node() ? svg.node().clientHeight : window.innerHeight;
    initialize();
  </script>
</body>
</html>
